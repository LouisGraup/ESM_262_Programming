---
title: 'Looping'
author: "Naomi Tague"
date: "January, 2022"
output:
  slidy_presentation:
   highlight: pygments
  html_document: default
  pdf_document: default
  ioslides_presentation:
    highlight: pygments
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo =TRUE)

library(tidyverse)
library(purrr)
library(ggpubr)
```


# Comments/Questions 

looping.RMD


# Steps for running function over multiple inputs 


1. design a data structure to store results: sometimes this is automatic but not always
2. generate the  data (or read it in)
3. find ways to repeat things efficiently
  * *purr* family of function in R
  * more generally looping (*for*, *while*, ...others)
  

#  <span style="color:blue"> A bit more on Looping 



# Loops can be "nested" on loop inside the other

Example: Calculate NPV for

* a range of different interest rates and 
* a range of damages 
* that may be incurred 10 years in the future

Steps

* define inputs (interest rates, damages)
* define output (NPV)
* write the function
* create a data structure to store results where we vary both interest rates and damages
* use nested for loops to fill in the data structure

Try it first...

# Rcode
```{r npvfor, echo=TRUE, error=FALSE}

# write a function to compute npv
source("../R/compute_NPV.R")
compute_NPV
compute_NPV(20, discount=0.01, time=20)


#generate some input
damages = c(25,33,91,24)
# sensitivity to discount rate
discount_rates = seq(from=0.01, to=0.04, by=0.005)
yr=10

# note that the "simple" application doesn't work - why?
#compute_NPV(20, discount=discount_rates, value=damages)

# compute some npv's for different discount rates for each damage
# first generate a dataframe to store results - we have both damages and discount rates that are changing - so we need rows and columns
npvs = data.frame(matrix(nrow=length(damages), ncol=length(discount_rates)))

# here we have a 2-dimensional array - rows and columns
View(npvs)

# now use a nested for loop to populate
 for (i in 1:length(damages)) {
         for (j in 1:length(discount_rates)) {
       npvs[i,j]= compute_NPV(value=damages[i],       discount=discount_rates[j],time=yr )

         }
 }
 npvs
 
 
 #some data wrangling to make it pretty
colnames(npvs)=discount_rates
rownames(npvs)=damages
 npvs
 
# how do I plot this with ggplot - add a column for original value and then rearrage
 npvs$damage = rownames(npvs)
 npvsg =npvs %>% pivot_longer(!damage,names_to="dis", values_to="npv")
 head(npvsg)
 ggplot(npvsg, aes(x=damage, y=npv, col=dis))+geom_point()+labs(col="Discount\nRate")
 
 # how about summing all the damages
 npv.total =npvsg %>% group_by(dis) %>% summarize(t=sum(npv))
 ggplot(npv.total, aes(dis,t, fill=dis))+geom_col() + labs(x="Discount Rate", y="Total ($)")

 
 # we could also do the repetition with map_dfc from the purr family of functions
 #generate some input
damages = c(25,33,91,24)
# sensitivity to discount rate
discount_rates = seq(from=0.01, to=0.04, by=0.005)
yr=10

# with purr family, map_dfc runs the function for each value and returns as a data frame 

npvs = pmap(list(discount_rates), compute_NPV, time=10, value=damages)
# turn into a data frame
npvs = as.data.frame(npvs, col.names=discount_rates)
npvs$damage = damages

# clean up and plot
 npvsg =npvs %>% pivot_longer(!damage,names_to="dis", values_to="npv")
 head(npvsg)
 ggplot(npvsg, aes(x=damage, y=npv, col=dis))+geom_point()+labs(col="Discount\nRate")
 
 
 # how about summing all the damages
 npv.total =npvsg %>% group_by(dis) %>% summarize(t=sum(npv))
 ggplot(npv.total, aes(dis,t, fill=dis))+geom_col() + labs(x="Discount Rate", y="Total ($)")

 
 
```

# Some other types of loops

* while
  useful for repeating until a condition is met

Example
if a metal toxin in a lake increases by 1% per year, how many years will it take for the metal level to be greater than 30 units, if toxin is current at 5 units


```{r} 

# accumulate pollutant until a threshold - how many years does it take

# initial conditions
yr=1
pollutant_level = 5

# loop
while ((pollutant_level < 30) &&(yr < 1000))  {
  # increase pollutant
pollutant_level = pollutant_level + 0.01* pollutant_level 
# keep track of time
yr = yr + 1
}

pollutant_level
yr

# while loop dangers
# what if it doesn't end....

# see below - I left it commented out -because it will run for ever :)
# you can use controlC to stop

#while ((pollutant_level < 30))  {
  # increase pollutant
#pollutant_level = pollutant_level - 0.01* pollutant_level 
#}


```

# Assignment 3
* recreate *possible_cars* from looping.RMD; add an additional super light car with mass 5,000 kg, surface area 10m2

* provide 3 new estimates of power required that includes this super light car in the mix
(one for each approach to repeating calculations)

* turn these 3 estimates in as Assignment 3 on Gauchospace; You should also try to recreate the graphs with a 4th car, you don't need to turn in the graphs; we will go over in class


# To Review for next class

* DataTypes.Rmd
